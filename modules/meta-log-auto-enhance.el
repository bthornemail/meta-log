;;; meta-log-auto-enhance.el --- Automatic self-enhancement from knowledge graph

;; Copyright (C) 2025 Automaton System
;; Author: Brian Thorne
;; Version: 1.0.0

;;; Commentary:

;; Automatically enhance meta-log from knowledge graph analysis:
;; - Auto-update WordNet with learned mappings
;; - Generate missing modules on-demand
;; - Continuous learning from new documents
;; - Gap analysis and predictive suggestions

;;; Code:

(require 'cl-lib)
(require 'meta-log-knowledge-graph)
(require 'meta-log-kg-learning)
(require 'meta-log-metacircular)

;;; Auto-Enhancement Configuration

(defvar meta-log-auto-enhance-enabled t
  "Enable automatic enhancement from knowledge graph.")

(defvar meta-log-auto-enhance-min-frequency 5
  "Minimum frequency for pattern to trigger enhancement.")

(defvar meta-log-auto-enhance-watch-dirs nil
  "List of directories to watch for new documents.")

(defvar meta-log-auto-enhance--last-run nil
  "Timestamp of last auto-enhancement run.")

;;; Implementation 1: Auto-Apply Learned WordNet Mappings

(defun meta-log-auto-enhance-wordnet ()
  "Automatically apply learned WordNet mappings.
Returns number of new mappings applied."
  (interactive)

  (let ((new-mappings (meta-log-kg-learn-wordnet-mappings))
        (applied 0))

    (message "Auto-enhancing WordNet with %d new mappings..." (length new-mappings))

    ;; Apply mappings
    (dolist (mapping new-mappings)
      (let ((word (car mapping))
            (dim (cdr mapping)))
        ;; Only add if not already present
        (unless (assoc word meta-log-wordnet--dimension-mappings)
          (push (cons word dim) meta-log-wordnet--dimension-mappings)
          (setq applied (1+ applied)))))

    ;; Save enhanced mappings
    (meta-log-auto-enhance-save-wordnet-mappings)

    (message "âœ“ Applied %d new WordNet mappings" applied)
    applied))

(defun meta-log-auto-enhance-save-wordnet-mappings ()
  "Save enhanced WordNet mappings to file."
  (let ((output-file "meta-log-wordnet-learned.el"))
    (with-temp-file output-file
      (insert ";;; meta-log-wordnet-learned.el --- Learned WordNet mappings\n\n")
      (insert ";; This file is automatically generated from knowledge graph analysis.\n")
      (insert (format ";; Generated: %s\n" (format-time-string "%Y-%m-%d %H:%M:%S")))
      (insert (format ";; Total mappings: %d\n\n" (length meta-log-wordnet--dimension-mappings)))
      (insert "(setq meta-log-wordnet--dimension-mappings\n")
      (insert "  '(")
      (dolist (mapping meta-log-wordnet--dimension-mappings)
        (insert (format "\n    (\"%s\" . \"%s\")" (car mapping) (cdr mapping))))
      (insert "))\n\n")
      (insert "(provide 'meta-log-wordnet-learned)\n"))

    (message "Saved enhanced WordNet to %s" output-file)))

;;; Implementation 2: Auto-Generate Missing Modules

(defun meta-log-auto-enhance-generate-modules (&optional top-n)
  "Auto-generate the TOP-N most needed modules.
Returns list of generated module files."
  (interactive "nGenerate top N modules (default 5): ")

  (setq top-n (or top-n 5))

  (let ((suggestions (meta-log-kg-discover-missing-modules))
        (generated '()))

    (message "Generating top %d suggested modules..." top-n)

    ;; Filter for high-value modules
    (setq suggestions
          (cl-remove-if (lambda (mod)
                         ;; Skip generic words
                         (member (plist-get mod :topic)
                                '("the" "and" "for" "with" "from" "inbox")))
                       suggestions))

    ;; Generate top N
    (dotimes (i (min top-n (length suggestions)))
      (let* ((mod (nth i suggestions))
             (topic (plist-get mod :topic))
             (filename (format "meta-log-%s.el" topic))
             (code (meta-log-kg-generate-module topic)))

        (with-temp-file filename
          (insert code))

        (push filename generated)
        (message "  âœ“ Generated %s" filename)))

    (message "Generated %d modules" (length generated))
    generated))

;;; Implementation 3: Gap Analysis

(defun meta-log-auto-enhance-gap-analysis ()
  "Perform gap analysis: what's mentioned vs what's implemented.
Returns report of gaps."
  (interactive)

  (let ((gaps '())
        (concept-freq (make-hash-table :test 'equal)))

    (message "Performing gap analysis...")

    ;; Count concept mentions
    (maphash (lambda (id node)
               (let ((label (downcase (meta-log-kg-node-label node))))
                 (puthash label (1+ (or (gethash label concept-freq) 0))
                         concept-freq)))
             meta-log-kg--concept-index)

    ;; Check against existing meta-log features
    (let ((existing-features
           (list "prolog" "datalog" "r5rs" "wordnet" "template" "federation"
                 "crypto" "mqtt" "webrtc" "identity" "protocol" "server"
                 "collective" "verifiable" "canvas" "geometric" "metacircular"
                 "knowledge" "graph" "learning" "auto" "enhance")))

      (maphash (lambda (concept count)
                 (when (and (>= count 20)  ; Mentioned 20+ times
                           (> (length concept) 4)  ; Not too short
                           (not (member concept existing-features)))

                   ;; Check if implemented
                   (let ((implemented (meta-log-auto-enhance-check-implementation concept)))
                     (unless implemented
                       (push (list :concept concept
                                 :mentions count
                                 :implemented nil
                                 :gap-score (/ (float count) 100))
                             gaps)))))
               concept-freq))

    ;; Sort by gap score
    (setq gaps (sort gaps
                    (lambda (a b)
                      (> (plist-get a :gap-score)
                         (plist-get b :gap-score)))))

    ;; Generate report
    (with-output-to-temp-buffer "*meta-log-gap-analysis*"
      (princ "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n")
      (princ "â•‘  META-LOG GAP ANALYSIS REPORT                           â•‘\n")
      (princ "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")
      (princ (format "Found %d capability gaps\n\n" (length gaps)))

      (let ((i 1))
        (dolist (gap (cl-subseq gaps 0 (min 20 (length gaps))))
          (princ (format "%2d. %s\n" i (plist-get gap :concept)))
          (princ (format "    Mentioned: %d times\n" (plist-get gap :mentions)))
          (princ (format "    Status: NOT IMPLEMENTED\n"))
          (princ (format "    Suggestion: Create meta-log-%s\n\n"
                        (plist-get gap :concept)))
          (setq i (1+ i)))))

    (message "Gap analysis complete. See buffer *meta-log-gap-analysis*")
    gaps))

(defun meta-log-auto-enhance-check-implementation (concept)
  "Check if CONCEPT is implemented in meta-log.
Returns t if implemented, nil otherwise."
  ;; Check if module exists
  (or (locate-library (format "meta-log-%s" concept))
      ;; Check if function exists
      (fboundp (intern (format "meta-log-%s-initialize" concept)))
      ;; Check in knowledge graph for implementation files
      (let ((found nil))
        (maphash (lambda (id node)
                   (when (and (eq (meta-log-kg-node-type node) 'document)
                             (string-match-p "\\.el$" (or (meta-log-kg-node-source-file node) ""))
                             (string-match-p concept (meta-log-kg-node-label node)))
                     (setq found t)))
                meta-log-kg--document-index)
        found)))

;;; Implementation 4: Predictive Suggestions

(defvar meta-log-auto-enhance--context-history '()
  "History of user's recent queries and operations.")

(defun meta-log-auto-enhance-predict-needs ()
  "Predict what the user might need next based on context.
Returns list of suggestions."
  (interactive)

  (let ((suggestions '())
        (recent-topics (make-hash-table :test 'equal)))

    ;; Analyze recent context
    (dolist (context meta-log-auto-enhance--context-history)
      (dolist (word (split-string context))
        (puthash (downcase word) (1+ (or (gethash (downcase word) recent-topics) 0))
                recent-topics)))

    ;; Find related concepts from knowledge graph
    (maphash (lambda (word count)
               (when (>= count 2)
                 ;; Find related documents
                 (let ((related (meta-log-kg-query word)))
                   (dolist (doc related)
                     (let ((keywords (plist-get (meta-log-kg-node-properties doc) :keywords)))
                       (dolist (kw keywords)
                         (unless (string= (downcase kw) word)
                           (push (list :suggestion kw
                                     :relevance count
                                     :reason (format "Related to '%s'" word))
                                 suggestions))))))))
            recent-topics)

    ;; Remove duplicates and sort
    (setq suggestions (cl-remove-duplicates suggestions
                                           :test (lambda (a b)
                                                  (string= (plist-get a :suggestion)
                                                          (plist-get b :suggestion)))))
    (setq suggestions (sort suggestions
                           (lambda (a b)
                             (> (plist-get a :relevance)
                                (plist-get b :relevance)))))

    ;; Show suggestions
    (when suggestions
      (message "\nğŸ’¡ Suggestions based on your recent work:")
      (dotimes (i (min 5 (length suggestions)))
        (let ((sug (nth i suggestions)))
          (message "  â€¢ %s (%s)"
                  (plist-get sug :suggestion)
                  (plist-get sug :reason)))))

    suggestions))

(defun meta-log-auto-enhance-track-context (query)
  "Track QUERY in context history for predictions."
  (push query meta-log-auto-enhance--context-history)
  ;; Keep last 20 queries
  (when (> (length meta-log-auto-enhance--context-history) 20)
    (setq meta-log-auto-enhance--context-history
          (cl-subseq meta-log-auto-enhance--context-history 0 20))))

;;; Implementation 5: Continuous Learning Loop

(defun meta-log-auto-enhance-continuous-learning ()
  "Start continuous learning loop.
Watches for new documents and auto-enhances."
  (interactive)

  (message "Starting continuous learning loop...")

  (unless meta-log-auto-enhance-watch-dirs
    (user-error "No watch directories configured. Set meta-log-auto-enhance-watch-dirs"))

  ;; Initial enhancement
  (meta-log-auto-enhance-run)

  ;; Schedule periodic re-enhancement
  (run-with-timer 300 300 'meta-log-auto-enhance-check-and-run))

(defun meta-log-auto-enhance-check-and-run ()
  "Check for new documents and run enhancement if needed."
  (when meta-log-auto-enhance-enabled
    (let ((new-docs-found nil))

      ;; Check watch directories
      (dolist (dir meta-log-auto-enhance-watch-dirs)
        (when (file-directory-p dir)
          ;; Simple check: compare file count
          (let ((current-count (length (directory-files-recursively dir "\\.\(md\\|org\)$"))))
            (when (or (not meta-log-auto-enhance--last-run)
                     new-docs-found)
              (setq new-docs-found t)))))

      (when new-docs-found
        (message "New documents detected. Running auto-enhancement...")
        (meta-log-auto-enhance-run)))))

(defun meta-log-auto-enhance-run ()
  "Run full auto-enhancement cycle.
Returns report of enhancements made."
  (interactive)

  (let ((report '()))

    (message "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    (message "â•‘  AUTO-ENHANCEMENT RUNNING                               â•‘")
    (message "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

    ;; 1. Update WordNet
    (let ((wordnet-count (meta-log-auto-enhance-wordnet)))
      (push (cons 'wordnet-mappings wordnet-count) report))

    ;; 2. Gap analysis
    (let ((gaps (meta-log-auto-enhance-gap-analysis)))
      (push (cons 'gaps-found (length gaps)) report))

    ;; 3. Predictive suggestions
    (let ((suggestions (meta-log-auto-enhance-predict-needs)))
      (push (cons 'suggestions (length suggestions)) report))

    ;; Update timestamp
    (setq meta-log-auto-enhance--last-run (current-time))

    (message "\nâœ“ Auto-enhancement complete!")
    (message "  â€¢ WordNet mappings: %d" (cdr (assoc 'wordnet-mappings report)))
    (message "  â€¢ Gaps found: %d" (cdr (assoc 'gaps-found report)))
    (message "  â€¢ Suggestions: %d\n" (cdr (assoc 'suggestions report)))

    report))

;;; Enhanced Query Functions with Auto-Learning

(defun meta-log-kg-query-enhanced (query)
  "Enhanced version of meta-log-kg-query with auto-learning.
QUERY is the search string.
Tracks context and provides predictions."
  (interactive "sQuery: ")

  ;; Track for predictions
  (meta-log-auto-enhance-track-context query)

  ;; Run normal query
  (let ((results (meta-log-kg-query query)))

    ;; Show results
    (message "Found %d results" (length results))

    ;; Provide predictions
    (meta-log-auto-enhance-predict-needs)

    results))

;;; Setup and Configuration

(defun meta-log-auto-enhance-setup (watch-directories)
  "Setup auto-enhancement with WATCH-DIRECTORIES.
Enables continuous learning from these directories."
  (interactive
   (list (split-string
          (read-string "Watch directories (space-separated): ")
          " " t)))

  (setq meta-log-auto-enhance-watch-dirs watch-directories)
  (setq meta-log-auto-enhance-enabled t)

  (message "Auto-enhancement configured:")
  (message "  Watch directories: %S" watch-directories)
  (message "  Min frequency: %d" meta-log-auto-enhance-min-frequency)
  (message "\nRun (meta-log-auto-enhance-continuous-learning) to start continuous learning"))

(provide 'meta-log-auto-enhance)

;;; meta-log-auto-enhance.el ends here
